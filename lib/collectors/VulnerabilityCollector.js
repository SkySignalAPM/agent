import { exec } from "child_process";
import { readFileSync, existsSync } from "fs";
import { join } from "path";

/**
 * VulnerabilityCollector
 * Runs `npm audit --json` (or parses a cached audit file) once per hour
 * to detect known vulnerabilities in installed packages.
 *
 * Only reports high and critical vulnerabilities to reduce noise.
 *
 * Payload: { critical, high, moderate, vulnerabilities: [{package, severity, title, fixAvailable}] }
 */
export default class VulnerabilityCollector {
  constructor(options = {}) {
    this.client = options.client;
    this.host = options.host || "unknown-host";
    this.appVersion = options.appVersion || "unknown";
    this.interval = options.interval || 3600000; // 1 hour
    this.debug = options.debug || false;
    this.auditTimeout = options.auditTimeout || 30000; // 30 second timeout for npm audit

    this.intervalId = null;
    this._lastAuditHash = null;
  }

  _log(...args) {
    if (this.debug) {
      console.log("[SkySignal:Vulnerability]", ...args);
    }
  }

  _warn(...args) {
    console.warn("[SkySignal:Vulnerability]", ...args);
  }

  start() {
    if (this.intervalId) {
      this._warn("Already started");
      return;
    }

    // Delay initial collect by 60s to let the app fully start
    setTimeout(() => {
      this._collect();
    }, 60000);

    this.intervalId = setInterval(() => {
      this._collect();
    }, this.interval);

    this._log(`Started (interval: ${this.interval}ms)`);
  }

  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this._log("Stopped");
  }

  async _collect() {
    try {
      const auditData = await this._runAudit();
      if (!auditData) return;

      const parsed = this._parseAuditData(auditData);
      if (!parsed) return;

      // Only report if there are high or critical vulnerabilities
      const hasSignificant = parsed.critical > 0 || parsed.high > 0;

      // Deduplicate - don't re-send identical results
      const hash = JSON.stringify({ c: parsed.critical, h: parsed.high, m: parsed.moderate });
      if (hash === this._lastAuditHash) {
        this._log("No change in vulnerability status, skipping");
        return;
      }
      this._lastAuditHash = hash;

      const metric = {
        timestamp: new Date(),
        host: this.host,
        appVersion: this.appVersion,
        critical: parsed.critical,
        high: parsed.high,
        moderate: parsed.moderate,
        vulnerabilities: parsed.vulnerabilities,
        hasSignificant
      };

      if (this.client) {
        this.client.addVulnerabilityMetric(metric);
      }

      this._log(`Collected: ${parsed.critical} critical, ${parsed.high} high, ${parsed.moderate} moderate`);
    } catch (error) {
      this._warn("Collection error:", error.message);
    }
  }

  /**
   * Run npm audit --json or read from cached file
   * @returns {Promise<Object|null>} Parsed JSON audit data
   */
  _runAudit() {
    return new Promise((resolve) => {
      // First check if a cached audit file exists (e.g., from CI pipeline)
      const cwd = process.cwd();
      const cachedPath = join(cwd, "npm-audit.json");
      if (existsSync(cachedPath)) {
        try {
          const data = readFileSync(cachedPath, "utf-8");
          const parsed = JSON.parse(data);
          this._log("Using cached npm-audit.json");
          resolve(parsed);
          return;
        } catch (_) {
          this._log("Cached npm-audit.json invalid, running npm audit");
        }
      }

      // Run npm audit --json
      exec("npm audit --json 2>/dev/null", {
        cwd,
        timeout: this.auditTimeout,
        maxBuffer: 5 * 1024 * 1024 // 5MB buffer for large audit outputs
      }, (error, stdout, _stderr) => {
        // npm audit exits with non-zero when vulnerabilities exist, which is expected
        if (stdout) {
          try {
            const parsed = JSON.parse(stdout);
            resolve(parsed);
            return;
          } catch (_) {
            this._warn("Failed to parse npm audit output");
          }
        }

        // If npm audit completely failed (not found, etc.)
        if (error && !stdout) {
          this._log("npm audit not available:", error.message);
        }

        resolve(null);
      });
    });
  }

  /**
   * Parse npm audit JSON output into our normalized format
   * Handles both npm v6 and v7+ audit output formats
   */
  _parseAuditData(data) {
    try {
      let critical = 0;
      let high = 0;
      let moderate = 0;
      const vulnerabilities = [];

      // npm v7+ format: { vulnerabilities: { packageName: { severity, ... } } }
      if (data.vulnerabilities && typeof data.vulnerabilities === "object") {
        for (const [pkgName, vuln] of Object.entries(data.vulnerabilities)) {
          const severity = vuln.severity || "unknown";

          if (severity === "critical") critical++;
          else if (severity === "high") high++;
          else if (severity === "moderate") moderate++;
          else continue; // Skip low/info

          // Only include high and critical in the detailed list
          if (severity === "critical" || severity === "high") {
            vulnerabilities.push({
              package: pkgName,
              severity,
              title: vuln.name || vuln.title || pkgName,
              fixAvailable: !!vuln.fixAvailable,
              range: vuln.range || null,
              via: Array.isArray(vuln.via)
                ? vuln.via.filter(v => typeof v === "string").slice(0, 3)
                : []
            });
          }
        }
      }
      // npm v6 format: { advisories: { id: { ... } }, metadata: { vulnerabilities: { ... } } }
      else if (data.metadata?.vulnerabilities) {
        const meta = data.metadata.vulnerabilities;
        critical = meta.critical || 0;
        high = meta.high || 0;
        moderate = meta.moderate || 0;

        if (data.advisories) {
          for (const [, advisory] of Object.entries(data.advisories)) {
            const severity = advisory.severity || "unknown";
            if (severity !== "critical" && severity !== "high") continue;

            vulnerabilities.push({
              package: advisory.module_name || "unknown",
              severity,
              title: advisory.title || "Unknown vulnerability",
              fixAvailable: !!advisory.patched_versions && advisory.patched_versions !== "<0.0.0",
              range: advisory.vulnerable_versions || null,
              via: []
            });
          }
        }
      }

      // Cap vulnerabilities list at 50
      return {
        critical,
        high,
        moderate,
        vulnerabilities: vulnerabilities.slice(0, 50)
      };
    } catch (error) {
      this._warn("Failed to parse audit data:", error.message);
      return null;
    }
  }
}
