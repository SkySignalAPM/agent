/**
 * VulnerabilityCollector tests — _parseAuditData for npm v6 and v7 formats.
 */

import { expect } from 'chai';
import VulnerabilityCollector from '../../../lib/collectors/VulnerabilityCollector.js';

describe('VulnerabilityCollector', function () {

  let collector;

  beforeEach(function () {
    collector = new VulnerabilityCollector({
      client: null,
      host: 'test-host'
    });
  });

  // ==========================================
  // constructor
  // ==========================================
  describe('constructor', function () {

    it('sets default values', function () {
      expect(collector.interval).to.equal(3600000); // 1 hour
      expect(collector.auditTimeout).to.equal(30000);
      expect(collector._lastAuditHash).to.be.null;
    });
  });

  // ==========================================
  // _parseAuditData — npm v7+ format
  // ==========================================
  describe('_parseAuditData (npm v7+ format)', function () {

    it('parses v7 format with severity counts', function () {
      const data = {
        vulnerabilities: {
          'lodash': { severity: 'critical', name: 'lodash', fixAvailable: true, range: '<4.17.21', via: ['prototype pollution'] },
          'express': { severity: 'high', name: 'express', fixAvailable: false, via: ['open redirect'] },
          'debug': { severity: 'moderate', name: 'debug', fixAvailable: true, via: [] },
          'qs': { severity: 'low', name: 'qs', fixAvailable: true, via: [] }
        }
      };

      const result = collector._parseAuditData(data);
      expect(result.critical).to.equal(1);
      expect(result.high).to.equal(1);
      expect(result.moderate).to.equal(1);
    });

    it('only includes high and critical in vulnerabilities list', function () {
      const data = {
        vulnerabilities: {
          'lodash': { severity: 'critical', name: 'lodash', fixAvailable: true, via: ['a'] },
          'debug': { severity: 'moderate', name: 'debug', fixAvailable: true, via: [] }
        }
      };

      const result = collector._parseAuditData(data);
      expect(result.vulnerabilities).to.have.lengthOf(1);
      expect(result.vulnerabilities[0].package).to.equal('lodash');
      expect(result.vulnerabilities[0].severity).to.equal('critical');
    });

    it('handles fixAvailable boolean', function () {
      const data = {
        vulnerabilities: {
          'pkg': { severity: 'high', fixAvailable: true, via: [] }
        }
      };

      const result = collector._parseAuditData(data);
      expect(result.vulnerabilities[0].fixAvailable).to.be.true;
    });

    it('filters via to strings only and limits to 3', function () {
      const data = {
        vulnerabilities: {
          'pkg': {
            severity: 'critical',
            via: ['a', { name: 'obj' }, 'b', 'c', 'd'],
            fixAvailable: false
          }
        }
      };

      const result = collector._parseAuditData(data);
      // Should only include string entries, max 3
      expect(result.vulnerabilities[0].via).to.deep.equal(['a', 'b', 'c']);
    });

    it('skips low severity entries', function () {
      const data = {
        vulnerabilities: {
          'pkg': { severity: 'low', via: [] }
        }
      };

      const result = collector._parseAuditData(data);
      expect(result.critical).to.equal(0);
      expect(result.high).to.equal(0);
      expect(result.moderate).to.equal(0);
      expect(result.vulnerabilities).to.have.lengthOf(0);
    });

    it('handles empty vulnerabilities object', function () {
      const result = collector._parseAuditData({ vulnerabilities: {} });
      expect(result.critical).to.equal(0);
      expect(result.high).to.equal(0);
      expect(result.moderate).to.equal(0);
      expect(result.vulnerabilities).to.have.lengthOf(0);
    });
  });

  // ==========================================
  // _parseAuditData — npm v6 format
  // ==========================================
  describe('_parseAuditData (npm v6 format)', function () {

    it('parses v6 format with metadata.vulnerabilities', function () {
      const data = {
        metadata: {
          vulnerabilities: { critical: 2, high: 3, moderate: 5, low: 10, info: 0 }
        },
        advisories: {
          '1234': { module_name: 'express', severity: 'critical', title: 'RCE vulnerability', patched_versions: '>=4.18.0', vulnerable_versions: '<4.18.0' },
          '1235': { module_name: 'lodash', severity: 'high', title: 'Prototype pollution', patched_versions: '>=4.17.21', vulnerable_versions: '<4.17.21' },
          '1236': { module_name: 'debug', severity: 'moderate', title: 'ReDoS', patched_versions: '>=3.2.0', vulnerable_versions: '<3.2.0' }
        }
      };

      const result = collector._parseAuditData(data);
      expect(result.critical).to.equal(2);
      expect(result.high).to.equal(3);
      expect(result.moderate).to.equal(5);
    });

    it('only includes high and critical advisories in vulnerabilities list', function () {
      const data = {
        metadata: { vulnerabilities: { critical: 1, high: 1, moderate: 1 } },
        advisories: {
          '1': { module_name: 'a', severity: 'critical', title: 'Critical vuln', patched_versions: '>=1.0', vulnerable_versions: '<1.0' },
          '2': { module_name: 'b', severity: 'high', title: 'High vuln', patched_versions: '>=2.0', vulnerable_versions: '<2.0' },
          '3': { module_name: 'c', severity: 'moderate', title: 'Mod vuln', patched_versions: '>=3.0', vulnerable_versions: '<3.0' }
        }
      };

      const result = collector._parseAuditData(data);
      expect(result.vulnerabilities).to.have.lengthOf(2);
      const pkgs = result.vulnerabilities.map(v => v.package);
      expect(pkgs).to.include('a');
      expect(pkgs).to.include('b');
    });

    it('detects fixAvailable from patched_versions', function () {
      const data = {
        metadata: { vulnerabilities: { critical: 1, high: 1 } },
        advisories: {
          '1': { module_name: 'fixable', severity: 'critical', patched_versions: '>=1.0' },
          '2': { module_name: 'unfixable', severity: 'high', patched_versions: '<0.0.0' }
        }
      };

      const result = collector._parseAuditData(data);
      const fixable = result.vulnerabilities.find(v => v.package === 'fixable');
      const unfixable = result.vulnerabilities.find(v => v.package === 'unfixable');
      expect(fixable.fixAvailable).to.be.true;
      expect(unfixable.fixAvailable).to.be.false;
    });

    it('handles missing advisories', function () {
      const data = {
        metadata: { vulnerabilities: { critical: 1, high: 0, moderate: 0 } }
      };

      const result = collector._parseAuditData(data);
      expect(result.critical).to.equal(1);
      expect(result.vulnerabilities).to.have.lengthOf(0);
    });
  });

  // ==========================================
  // _parseAuditData — edge cases
  // ==========================================
  describe('_parseAuditData (edge cases)', function () {

    it('caps vulnerabilities list at 50', function () {
      const vulns = {};
      for (let i = 0; i < 60; i++) {
        vulns[`pkg${i}`] = { severity: 'critical', fixAvailable: false, via: [] };
      }
      const result = collector._parseAuditData({ vulnerabilities: vulns });
      expect(result.vulnerabilities).to.have.lengthOf(50);
    });

    it('returns null for completely unrecognized format', function () {
      const result = collector._parseAuditData({ random: 'data' });
      // No metadata.vulnerabilities and no vulnerabilities object
      // Should return { critical: 0, high: 0, moderate: 0, vulnerabilities: [] }
      expect(result.critical).to.equal(0);
      expect(result.vulnerabilities).to.have.lengthOf(0);
    });

    it('returns null on parse error', function () {
      // Force an error by passing something that causes Object.entries to fail
      const result = collector._parseAuditData(null);
      expect(result).to.be.null;
    });
  });
});
